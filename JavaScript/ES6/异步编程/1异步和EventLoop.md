JavaScript是单线程的语言，就是同一个时间只能做同一件事。

## 为什么是单线程

我们可以这样假设，假如JavaScript是多线程，其中一个线程在某个DOM节点上添加了一个元素，而另一个线程删除了该节点，这时浏览器应该以哪一个线程为准？

所以为了避免复杂性，JavaScript从一开始就固定了其单线程的运作方式。

这里需要注意的是HTML5提供的WebWorker，其虽然提供了多线程的解决方式，不过其原理是以一个主线程为基准，其他子线程依附于该主线程，并且子线程中不能更改DOM，且不能使用除setTimeout，setInterval等的window方法。

## 异步

单线程意味着程序一行一行的执行，等待上一个任务完成后才会进行接下来的任务，此时当遇到计算量很大或者是一些网络、IO流时，因其需要大量耗时的工作去完成，如果依旧单线程处理方式，页面便会变得卡顿，这是用户所不能容忍的，于是异步便油然而生了。

异步任务指的是不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程中运行。具体来说，异步任务运行机制如下：

1. 所有同步任务都在主线程上执行，形成一个`执行栈`；
2. 主线程之外还有一个`任务队列`。只要异步任务有了结果，就在`任务队列`中放置一个事件；
3. 一旦`执行栈`中的所有同步任务执行完毕，系统就会读取`任务队列中`（先进先出），看看里面有哪些事件，然后事件进入执行栈，开始执行；
4. 主线程重复执行第三步。

`任务队列`就是一个事件的队列（消息的队列），当一个异步任务执行完成，就会在`任务队列`中注册一个事件，表示相关的异步任务可以进入`执行栈`了。

`回调函数`就是那些会被主线程挂起的代码，异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

`任务队列`是一个先进先出的数据结构，排在前面的事件优先被主线程调取执行；主线程执行过程是自动的，只要`执行栈`一清空，便会读取任务队列中的第一个事件。但是由于存在定时器功能，主线程会首先检查一下事件的执行时间，某些事件只有在规定的时间，才能返回主线程。

## Event Loop

主线程从任务队列中读取事件，这个过程是循环不断的，所以这种运行机制又被称为Event Loop（事件循环）

![Event Loop](../../../images/async/event-loop.png)

我们看这个图可以知道，主线程在运行的时候，产生堆(heap)和栈(stack)，栈中的代码调用各种外部API，当执行到异步任务时，会在任务队列中添加各种事件(click, load, done)。只要栈中的代码执行完毕，任务队列中的第一个事件会进入栈（即主线程）中执行，执行完毕循环调用任务队列中的下一个事件，依次执行。

这里需要注意的知识点时定时器，即指定某些代码在多长时间后执行。

定时器主要有setTimeout和setInterval两个函数，这两个方法便不再介绍，这里只说时间为0时的定时器，即`setTimeout(callback, 0);`

这种时间为0的定时器表示当前执行栈结束后，立即执行（0ms间隔）指定的回调函数。HTML5规定，第二个参数的最小间隔不得低于4ms，若低于，则自动累加。

这里我的理解是任务队列中存储的是异步任务完成后所注册的事件，即异步任务越早完成越早往任务队列中注册事件，所以越早执行。

在NodeJS中，还提供了两个与任务队列相关的方法，即`setImmediate`和`process.nextTick`

`process.nextTick`指定的回调函数是在当前`执行栈`的尾部被触发，即在所有异步任务之前执行

`setImmediate`类似于`setTimeout(callback, 0);`。这里需要注意的是`setImmediate`和`setTimeout`以及`setIterval`是在当前任务队列尾部添加事件。

当递归调用`process.nextTick`时，因为并没有给其他异步程序机会，即一直执行的是`nextTick`，所以建议用`setImmediate`
